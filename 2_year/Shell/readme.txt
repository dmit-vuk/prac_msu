						Программа Шелл
Программа состоит из 5 модулей: main, polis, stack, funcs, list.

В данной реализации поддерживаются операции | || && & > >> < и скобки.

Контроль ввода был выполнен частично от того контроля, который был в калькуляторе.

				

						Модуль polis
Модуль для работы с польской записью выражения.
typedef struct
{
    void *data; //указатель на массив байтов
    size_t size; // размер массива
} Polis;
в массиве data данные хранятся побайтово. Сначала идёт один байт, его значением является то, сколько последующих байт относится к элементу. Далее идёт указатель на функцию (подробнее в funcs), а далее сам элемент: указатель на строку.

Для удобства были сделаны структуры:
typedef struct cmd_inf{
    char out;
    char *out_add;
    char in;
    char *and_and;
    char *or_or;
    char and_op;
    char or_op;
    int brackets;
    int and_was;
} cmd_inf;
Для записи выражения в польскую запись и

typedef struct pipes{
    int in;
    int out;
    int out_f;
    int in_f;
    jmp **jump;
    int status;
    int sdin;
    int sdout;
    int stdin_my;
    int stdout_my;
}pipes;
Для работы с конвейером.


						Модуль stack
Стек хранится следующим образом

typedef struct Stack
{
    size_t curr_size; // текущий размер стека
    size_t act_size; // сколько всего выделено под стек
    char *data; // данные
} Stack;
Данные хранятся аналогично побайтово.

Константы:
INIT_SIZE 1024 // размер при инициализации
MEM_EXH 3 // ошибка при pop_stack, пытаемся считаь больше возможного
MEM_OVER 4 // ошибка при попытке выделить больше памяти под стек.

Функция init_stack инициализиует стек с curr_size равным нулю и act_size = INIT_SIZE.

Функция delete_stack удаляет исходный стек, curr_size = act_size = 0.
Функция pop_stack(Stack *stack, void *res, size_t size_res) считывает со стека stack данные в переменную res размера size_res. Если возникает попытка считать больше данных, чем есть в стеке, возникает ошибка с кодом MEM_EXH.

Функция push_stack(Stack *stack, void *res, size_t size_res) записвает в стек stack данные в переменную res размера size_res. Если выделенного под стек места не хватает, то запрашивается удвоение длины стека. Если памяти не хватает, то выдаётся ошибка с кодом MEM_OVER

						Модуль funcs
Константы:
NON_CREAT 6
LEN 1024
WRONG_WR 11
WR_PIPE 12

В данном модуле реализованы функции для работы с данными в полизе.

comand_func считывает из полиза команду и заносит её в стек.

Функции out_add_func, out_func, in_func, считывают файл со стека, открывают его в нужном режиме и запоминают дескриптор этого файла, чтобы дальше уже читать/писать в/из него. При этом считается, что в выражении типа а > ф. ф - это файл. Если его не было, то он будет создан.

Функция or_func - функция конвейера a|b. Она забирает из стека а, пишет в выделенный ей канал результат своей работы. Из этого канала читает b и пишет уже в другой выделенный ей канал или в stdout.

Функции and_and_func, or_or_func - && и ||. Проверяют если команда на стеке, если да, то выполняют её и смотрят на статус её завершения. А далее по либо продолжает работу calculate_polis, либо && и || сообщают сколько команд надо пропустить.

						Модуль list
Модуль для работы со списком скипов. Для каждой из команд && и || заводится свой элемент в этом списке на сколько команд надо будет прыгнуть в полизе при неудачном/успешном завершении.

						Спецификации
в силу не хватки времени отсутствует реализация () <. Считается, что & может стоять только на конце строки. Если она стоит не в конце, будет соответствующее сообщение об ошибке. Завершение программы происходит по Ctrl+D или по Ctrl+С.

Здесь будет более актуальное решение.
https://github.com/DimaKurtsev/P5


